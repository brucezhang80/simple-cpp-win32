<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>StorageManager: StorageManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="media-flash-smart-media.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">StorageManager
   &#160;<span id="projectnumber">2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_storage_manager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">StorageManager Class Reference<div class="ingroups"><a class="el" href="group___m_a_i_n___g_r_o_u_p.html">Storage Manager Module</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A Static class, that simulates a fourth area to declare Variables, which is the Harddrive to keep them alive beyond the Program.  
 <a href="class_storage_manager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_storage_manager_8h_source.html">StorageManager.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ga2b1d394c674416b3d00c8bf887e3a4f4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_a_i_n___g_r_o_u_p.html#ga2b1d394c674416b3d00c8bf887e3a4f4">LoadPolicy</a> { <a class="el" href="group___m_a_i_n___g_r_o_u_p.html#gga2b1d394c674416b3d00c8bf887e3a4f4a44788df080fcf5b2d658742e54a354c4">REPLACE</a> = 0, 
<a class="el" href="group___m_a_i_n___g_r_o_u_p.html#gga2b1d394c674416b3d00c8bf887e3a4f4a3eaff69a39b7b7b487163ebc3a44205b">KEEP</a> = 1, 
<a class="el" href="group___m_a_i_n___g_r_o_u_p.html#gga2b1d394c674416b3d00c8bf887e3a4f4a7664f5659a32eff31dab3bd16c095e8f">KEEPPOINTERS</a> = 2
 }</td></tr>
<tr class="memdesc:ga2b1d394c674416b3d00c8bf887e3a4f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible behaviors to load the data.  <a href="group___m_a_i_n___g_r_o_u_p.html#ga2b1d394c674416b3d00c8bf887e3a4f4">More...</a><br /></td></tr>
<tr class="separator:ga2b1d394c674416b3d00c8bf887e3a4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0b3049042f6237c8f876517432b71c1d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a0b3049042f6237c8f876517432b71c1d"><td class="memTemplItemLeft" align="right" valign="top">static T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#a0b3049042f6237c8f876517432b71c1d">allocateStorage</a> (const std::string &amp;varName, Args...params)</td></tr>
<tr class="memdesc:a0b3049042f6237c8f876517432b71c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alloctes new storage, using the new-operator.  <a href="#a0b3049042f6237c8f876517432b71c1d">More...</a><br /></td></tr>
<tr class="separator:a0b3049042f6237c8f876517432b71c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd4c4b9593af7b4aaa2bfc34b7aeb4b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:affd4c4b9593af7b4aaa2bfc34b7aeb4b"><td class="memTemplItemLeft" align="right" valign="top">static T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#affd4c4b9593af7b4aaa2bfc34b7aeb4b">allocateStorageArray</a> (const std::string &amp;varName, size_t size)</td></tr>
<tr class="memdesc:affd4c4b9593af7b4aaa2bfc34b7aeb4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alloctes new storage, using the new[]-operator.  <a href="#affd4c4b9593af7b4aaa2bfc34b7aeb4b">More...</a><br /></td></tr>
<tr class="separator:affd4c4b9593af7b4aaa2bfc34b7aeb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac90cb452767a5e39a3e0d820cfc53c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#a0ac90cb452767a5e39a3e0d820cfc53c">freeStorage</a> (void *storagePointer)</td></tr>
<tr class="memdesc:a0ac90cb452767a5e39a3e0d820cfc53c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the storage pointed by storagePointer.  <a href="#a0ac90cb452767a5e39a3e0d820cfc53c">More...</a><br /></td></tr>
<tr class="separator:a0ac90cb452767a5e39a3e0d820cfc53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412c525465f38801e631e45286b53071"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#a412c525465f38801e631e45286b53071">contains</a> (std::string name)</td></tr>
<tr class="memdesc:a412c525465f38801e631e45286b53071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks, if a variable with this name exists on storage.  <a href="#a412c525465f38801e631e45286b53071">More...</a><br /></td></tr>
<tr class="separator:a412c525465f38801e631e45286b53071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9472bef7ba9a5333433a3931e8181e9e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9472bef7ba9a5333433a3931e8181e9e"><td class="memTemplItemLeft" align="right" valign="top">static T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#a9472bef7ba9a5333433a3931e8181e9e">getPointer</a> (std::string name)</td></tr>
<tr class="memdesc:a9472bef7ba9a5333433a3931e8181e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pointer to the variable specified by name.  <a href="#a9472bef7ba9a5333433a3931e8181e9e">More...</a><br /></td></tr>
<tr class="separator:a9472bef7ba9a5333433a3931e8181e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3e8aee088d707318e9801e4d0e611b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afa3e8aee088d707318e9801e4d0e611b"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#afa3e8aee088d707318e9801e4d0e611b">obtainPointer</a> (std::string name, T *pointer, size_t size, bool replace=true)</td></tr>
<tr class="memdesc:afa3e8aee088d707318e9801e4d0e611b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves a pointer from heap to storage.  <a href="#afa3e8aee088d707318e9801e4d0e611b">More...</a><br /></td></tr>
<tr class="separator:afa3e8aee088d707318e9801e4d0e611b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5f5146ce3049f52cd6dd1303cec451"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8f5f5146ce3049f52cd6dd1303cec451"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#a8f5f5146ce3049f52cd6dd1303cec451">copyPointer</a> (std::string name, T *pointer, size_t size, bool replace=true)</td></tr>
<tr class="memdesc:a8f5f5146ce3049f52cd6dd1303cec451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of the pointers data.  <a href="#a8f5f5146ce3049f52cd6dd1303cec451">More...</a><br /></td></tr>
<tr class="separator:a8f5f5146ce3049f52cd6dd1303cec451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac884d39bef24dfdefbe4afbe1999d89d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac884d39bef24dfdefbe4afbe1999d89d"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#ac884d39bef24dfdefbe4afbe1999d89d">observePointer</a> (std::string name, T *pointer, size_t size, bool replace=true)</td></tr>
<tr class="memdesc:ac884d39bef24dfdefbe4afbe1999d89d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Observes a pointer.  <a href="#ac884d39bef24dfdefbe4afbe1999d89d">More...</a><br /></td></tr>
<tr class="separator:ac884d39bef24dfdefbe4afbe1999d89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d760901a3b7b5cd9e830f7992d8504"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac2d760901a3b7b5cd9e830f7992d8504"><td class="memTemplItemLeft" align="right" valign="top">static T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#ac2d760901a3b7b5cd9e830f7992d8504">releasePointer</a> (std::string name, size_t *size=NULL, bool *isArray=NULL)</td></tr>
<tr class="memdesc:ac2d760901a3b7b5cd9e830f7992d8504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes the pointer from Storage and moves it to the heap.  <a href="#ac2d760901a3b7b5cd9e830f7992d8504">More...</a><br /></td></tr>
<tr class="separator:ac2d760901a3b7b5cd9e830f7992d8504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8189940dad5e0d901d93acdd08f4909b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a8189940dad5e0d901d93acdd08f4909b"><td class="memTemplItemLeft" align="right" valign="top">static T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#a8189940dad5e0d901d93acdd08f4909b">getVariable</a> (std::string name, bool enforce=false, Args...params)</td></tr>
<tr class="memdesc:a8189940dad5e0d901d93acdd08f4909b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer at the Storage, either an existing one or creates a new one.  <a href="#a8189940dad5e0d901d93acdd08f4909b">More...</a><br /></td></tr>
<tr class="separator:a8189940dad5e0d901d93acdd08f4909b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477984c70411871967e3d44a92a249d8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a477984c70411871967e3d44a92a249d8"><td class="memTemplItemLeft" align="right" valign="top">static T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#a477984c70411871967e3d44a92a249d8">getArray</a> (std::string name, size_t *size, bool enforce=false, bool enforce_size=false)</td></tr>
<tr class="memdesc:a477984c70411871967e3d44a92a249d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an arry pointer at the Storage, either an existing one or creates a new one.  <a href="#a477984c70411871967e3d44a92a249d8">More...</a><br /></td></tr>
<tr class="separator:a477984c70411871967e3d44a92a249d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257d70bad26e2b6e3ab1241f3725830e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#a257d70bad26e2b6e3ab1241f3725830e">removeVariable</a> (std::string name)</td></tr>
<tr class="memdesc:a257d70bad26e2b6e3ab1241f3725830e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permanently deletes the variable name from the storage.  <a href="#a257d70bad26e2b6e3ab1241f3725830e">More...</a><br /></td></tr>
<tr class="separator:a257d70bad26e2b6e3ab1241f3725830e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136edf2a78edf3ef24241b02d825e234"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a136edf2a78edf3ef24241b02d825e234"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="class_storage_variable.html">StorageVariable</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#a136edf2a78edf3ef24241b02d825e234">createVariable</a> (std::string name, bool unique=false, bool enforce=false, Args...params)</td></tr>
<tr class="memdesc:a136edf2a78edf3ef24241b02d825e234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="class_storage_variable.html" title="Storage Variable class. Use it to create a reference to variables created on storage. ">StorageVariable</a> to the given Name.  <a href="#a136edf2a78edf3ef24241b02d825e234">More...</a><br /></td></tr>
<tr class="separator:a136edf2a78edf3ef24241b02d825e234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6f89757ecb95cc74475dfa1432458f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adf6f89757ecb95cc74475dfa1432458f"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="class_storage_variable.html">StorageVariable</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#adf6f89757ecb95cc74475dfa1432458f">createArray</a> (std::string name, size_t *size, bool unique=false, bool enforce=false, bool enforce_size=false)</td></tr>
<tr class="memdesc:adf6f89757ecb95cc74475dfa1432458f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="class_storage_variable.html" title="Storage Variable class. Use it to create a reference to variables created on storage. ">StorageVariable</a> to the given Name, array version.  <a href="#adf6f89757ecb95cc74475dfa1432458f">More...</a><br /></td></tr>
<tr class="separator:adf6f89757ecb95cc74475dfa1432458f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6750cf63f61a20cfb34d93a1444a99a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae6750cf63f61a20cfb34d93a1444a99a"><td class="memTemplItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#ae6750cf63f61a20cfb34d93a1444a99a">derefVariable</a> (<a class="el" href="class_storage_variable.html">StorageVariable</a>&lt; T &gt; &amp;var)</td></tr>
<tr class="memdesc:ae6750cf63f61a20cfb34d93a1444a99a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes 1 reference to the variable used by var and makes var invalid.  <a href="#ae6750cf63f61a20cfb34d93a1444a99a">More...</a><br /></td></tr>
<tr class="separator:ae6750cf63f61a20cfb34d93a1444a99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802b1e7c12fb17783fac32c075fc792d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#a802b1e7c12fb17783fac32c075fc792d">setNothrow</a> (bool value)</td></tr>
<tr class="memdesc:a802b1e7c12fb17783fac32c075fc792d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the nothrow parameter.  <a href="#a802b1e7c12fb17783fac32c075fc792d">More...</a><br /></td></tr>
<tr class="separator:a802b1e7c12fb17783fac32c075fc792d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b37bf042283a20138fa084703336f33"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#a0b37bf042283a20138fa084703336f33">getNothrow</a> ()</td></tr>
<tr class="memdesc:a0b37bf042283a20138fa084703336f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the nothrow parameter.  <a href="#a0b37bf042283a20138fa084703336f33">More...</a><br /></td></tr>
<tr class="separator:a0b37bf042283a20138fa084703336f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35fe2b8483b8a93e14faee59d8f71d55"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#a35fe2b8483b8a93e14faee59d8f71d55">setAutoSave</a> (bool value)</td></tr>
<tr class="memdesc:a35fe2b8483b8a93e14faee59d8f71d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the AutoSave parameter.  <a href="#a35fe2b8483b8a93e14faee59d8f71d55">More...</a><br /></td></tr>
<tr class="separator:a35fe2b8483b8a93e14faee59d8f71d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76b83d64ca60038d49a092115e3348c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#ac76b83d64ca60038d49a092115e3348c">getAutoSave</a> ()</td></tr>
<tr class="memdesc:ac76b83d64ca60038d49a092115e3348c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the AutoSave parameter.  <a href="#ac76b83d64ca60038d49a092115e3348c">More...</a><br /></td></tr>
<tr class="separator:ac76b83d64ca60038d49a092115e3348c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3011c9d7bef056ec6f10d009ad14172"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#ab3011c9d7bef056ec6f10d009ad14172">setVerifyName</a> (bool value)</td></tr>
<tr class="memdesc:ab3011c9d7bef056ec6f10d009ad14172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the VerifyName parameter.  <a href="#ab3011c9d7bef056ec6f10d009ad14172">More...</a><br /></td></tr>
<tr class="separator:ab3011c9d7bef056ec6f10d009ad14172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457c9ffcd7714f10cefc8c6cbe615a02"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#a457c9ffcd7714f10cefc8c6cbe615a02">getVerifyName</a> ()</td></tr>
<tr class="memdesc:a457c9ffcd7714f10cefc8c6cbe615a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the VerifyName parameter.  <a href="#a457c9ffcd7714f10cefc8c6cbe615a02">More...</a><br /></td></tr>
<tr class="separator:a457c9ffcd7714f10cefc8c6cbe615a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5145182a002c2b1d26c2bd1ee7bce9ea"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#a5145182a002c2b1d26c2bd1ee7bce9ea">setLoadPolicy</a> (<a class="el" href="group___m_a_i_n___g_r_o_u_p.html#ga2b1d394c674416b3d00c8bf887e3a4f4">LoadPolicy</a> value)</td></tr>
<tr class="memdesc:a5145182a002c2b1d26c2bd1ee7bce9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the LoadPolicy parameter.  <a href="#a5145182a002c2b1d26c2bd1ee7bce9ea">More...</a><br /></td></tr>
<tr class="separator:a5145182a002c2b1d26c2bd1ee7bce9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886ed1ec85ec9f2e4a9d1eb549768db3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___m_a_i_n___g_r_o_u_p.html#ga2b1d394c674416b3d00c8bf887e3a4f4">LoadPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#a886ed1ec85ec9f2e4a9d1eb549768db3">getLoadPolicy</a> ()</td></tr>
<tr class="memdesc:a886ed1ec85ec9f2e4a9d1eb549768db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the LoadPolicy parameter.  <a href="#a886ed1ec85ec9f2e4a9d1eb549768db3">More...</a><br /></td></tr>
<tr class="separator:a886ed1ec85ec9f2e4a9d1eb549768db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40c05ee1f87944e2b12c78a1650a36f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#ab40c05ee1f87944e2b12c78a1650a36f">setName</a> (std::string value)</td></tr>
<tr class="memdesc:ab40c05ee1f87944e2b12c78a1650a36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Name parameter.  <a href="#ab40c05ee1f87944e2b12c78a1650a36f">More...</a><br /></td></tr>
<tr class="separator:ab40c05ee1f87944e2b12c78a1650a36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d626d5a89e26d0b274720df2c5791d"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#ab2d626d5a89e26d0b274720df2c5791d">getName</a> ()</td></tr>
<tr class="memdesc:ab2d626d5a89e26d0b274720df2c5791d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Name parameter.  <a href="#ab2d626d5a89e26d0b274720df2c5791d">More...</a><br /></td></tr>
<tr class="separator:ab2d626d5a89e26d0b274720df2c5791d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca281716c780a4cf2ca6ee1fba96fc3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#aeca281716c780a4cf2ca6ee1fba96fc3">setPath</a> (std::string value)</td></tr>
<tr class="memdesc:aeca281716c780a4cf2ca6ee1fba96fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Path parameter.  <a href="#aeca281716c780a4cf2ca6ee1fba96fc3">More...</a><br /></td></tr>
<tr class="separator:aeca281716c780a4cf2ca6ee1fba96fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd81fd234ba5547e0a85be4b2275c3a"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#a4fd81fd234ba5547e0a85be4b2275c3a">getPath</a> ()</td></tr>
<tr class="memdesc:a4fd81fd234ba5547e0a85be4b2275c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Path parameter.  <a href="#a4fd81fd234ba5547e0a85be4b2275c3a">More...</a><br /></td></tr>
<tr class="separator:a4fd81fd234ba5547e0a85be4b2275c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6027ebf6fac01093a9624e6c846c85"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#a5c6027ebf6fac01093a9624e6c846c85">save</a> ()</td></tr>
<tr class="memdesc:a5c6027ebf6fac01093a9624e6c846c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves all the Storage data to the Harddrive.  <a href="#a5c6027ebf6fac01093a9624e6c846c85">More...</a><br /></td></tr>
<tr class="separator:a5c6027ebf6fac01093a9624e6c846c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90db630d2bc803252cf587e0c558398"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#ab90db630d2bc803252cf587e0c558398">load</a> ()</td></tr>
<tr class="memdesc:ab90db630d2bc803252cf587e0c558398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads all available data from the Harddrive to the Storage.  <a href="#ab90db630d2bc803252cf587e0c558398">More...</a><br /></td></tr>
<tr class="separator:ab90db630d2bc803252cf587e0c558398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882341510e70c5075558b3bef9aa21c2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#a882341510e70c5075558b3bef9aa21c2">clear</a> ()</td></tr>
<tr class="memdesc:a882341510e70c5075558b3bef9aa21c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completly clears the manager.  <a href="#a882341510e70c5075558b3bef9aa21c2">More...</a><br /></td></tr>
<tr class="separator:a882341510e70c5075558b3bef9aa21c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32015eaf54467ed3c5c1cb317e92335f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#a32015eaf54467ed3c5c1cb317e92335f">generateRandom</a> (size_t keylenght=CryptoPP::AES::DEFAULT_KEYLENGTH)</td></tr>
<tr class="memdesc:a32015eaf54467ed3c5c1cb317e92335f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly generates a key and an iv.  <a href="#a32015eaf54467ed3c5c1cb317e92335f">More...</a><br /></td></tr>
<tr class="separator:a32015eaf54467ed3c5c1cb317e92335f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91892b0d109b21e13ff54e8fa32be55f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#a91892b0d109b21e13ff54e8fa32be55f">setCrypted</a> (bool value, const CryptoPP::SecByteBlock &amp;key=CryptoPP::SecByteBlock(), const CryptoPP::SecByteBlock &amp;iv=CryptoPP::SecByteBlock())</td></tr>
<tr class="memdesc:a91892b0d109b21e13ff54e8fa32be55f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets if the file should be crypted with a key.  <a href="#a91892b0d109b21e13ff54e8fa32be55f">More...</a><br /></td></tr>
<tr class="separator:a91892b0d109b21e13ff54e8fa32be55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94dd86710068d0df906c4a5b74fafd0e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#a94dd86710068d0df906c4a5b74fafd0e">getCrypted</a> ()</td></tr>
<tr class="memdesc:a94dd86710068d0df906c4a5b74fafd0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets if the file should be crypted and if needed it's key.  <a href="#a94dd86710068d0df906c4a5b74fafd0e">More...</a><br /></td></tr>
<tr class="separator:a94dd86710068d0df906c4a5b74fafd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3d81bd37c54f4ae327529944897811"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#a8e3d81bd37c54f4ae327529944897811">getCrypted</a> (CryptoPP::SecByteBlock &amp;key, CryptoPP::SecByteBlock &amp;iv)</td></tr>
<tr class="separator:a8e3d81bd37c54f4ae327529944897811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744996bc2fe9beb4e54010083b772950"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#a744996bc2fe9beb4e54010083b772950">getLoadProtocol</a> ()</td></tr>
<tr class="memdesc:a744996bc2fe9beb4e54010083b772950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the loading-protokol.  <a href="#a744996bc2fe9beb4e54010083b772950">More...</a><br /></td></tr>
<tr class="separator:a744996bc2fe9beb4e54010083b772950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeef0cdabd4c32d40a9cef9d649bb0de"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; void * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#afeef0cdabd4c32d40a9cef9d649bb0de">CorruptedPointers</a> ()</td></tr>
<tr class="memdesc:afeef0cdabd4c32d40a9cef9d649bb0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to a vector, that stores all the pointers, which were deleted on loading.  <a href="#afeef0cdabd4c32d40a9cef9d649bb0de">More...</a><br /></td></tr>
<tr class="separator:afeef0cdabd4c32d40a9cef9d649bb0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a8359a9e15d03cc2504a11a8a22a1d57c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8359a9e15d03cc2504a11a8a22a1d57c"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_storage_manager.html#a8359a9e15d03cc2504a11a8a22a1d57c">StorageVariable</a></td></tr>
<tr class="separator:a8359a9e15d03cc2504a11a8a22a1d57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A Static class, that simulates a fourth area to declare Variables, which is the Harddrive to keep them alive beyond the Program. </p>
<p>The <a class="el" href="class_storage_manager.html" title="A Static class, that simulates a fourth area to declare Variables, which is the Harddrive to keep the...">StorageManager</a> is a static class, used to manage data created on the "Storage". The Storage is used as a synonym for data, that should be placed on the Harddrive. <br />
 Of course, the Storage is not directly allocted on the harddrive, because this would cause massive slowdown effects. Als long as the program is running, the data will be stored at the heap. The <a class="el" href="class_storage_manager.html" title="A Static class, that simulates a fourth area to declare Variables, which is the Harddrive to keep the...">StorageManager</a> has it's own functions to declare and manage variables, that should be placed on the harddrive, and is optimized to do that. It also provides the <a class="el" href="class_storage_variable.html" title="Storage Variable class. Use it to create a reference to variables created on storage. ">StorageVariable</a> class, which allows easy access to the Storage. Notice that once you added the <a class="el" href="_storage_manager_8cpp.html" title="Implements the StorageManagers class non-template functions. ">StorageManager.cpp</a> file to you project, a <a class="el" href="class_storage_manager.html" title="A Static class, that simulates a fourth area to declare Variables, which is the Harddrive to keep the...">StorageManager</a> will automatically be created. The Manager is placed at the datasegment, so it will be constructed before the main routine starts and deleted after it ends. If not specified different, it will load data stored on the Harddrive on construction and save it on destruction. You can use a group of Macros (check <a class="el" href="group___m_a_i_n___g_r_o_u_p.html#TANC001">STORMAN_NOLOAD</a>) or the memberfunction <a class="el" href="class_storage_manager.html#a35fe2b8483b8a93e14faee59d8f71d55" title="Sets the AutoSave parameter. ">StorageManager::setAutoSave</a> to modify these. <br />
 With the <a class="el" href="class_storage_manager.html" title="A Static class, that simulates a fourth area to declare Variables, which is the Harddrive to keep the...">StorageManager</a> you are able to allocate and free memory, similar to the standard C++ functions (which are internally used). The main differenc is, that if you don't delete them before the program ends, the Manager will take care of them, meaning it will save them permanently on the Harddrive and then free the allocated Memory. And next time you start your program, it will automaticaly load them. The functions to do this are mainly <a class="el" href="class_storage_manager.html#a8189940dad5e0d901d93acdd08f4909b" title="Gets a pointer at the Storage, either an existing one or creates a new one. ">StorageManager::getVariable</a> and <a class="el" href="class_storage_manager.html#a477984c70411871967e3d44a92a249d8" title="Gets an arry pointer at the Storage, either an existing one or creates a new one. ...">StorageManager::getArray</a>. <a class="el" href="class_storage_manager.html#a257d70bad26e2b6e3ab1241f3725830e" title="Permanently deletes the variable name from the storage. ">StorageManager::removeVariable</a> can be usefull, too.</p>
<dl class="section warning"><dt>Warning</dt><dd>Pleace notice: On loading and saving, the Manager won't call any constructors or destructors. When The program ends, the space allocated will be freed, but without calling destructors. You have to make sure, that all data stored is fitted to be stored, so it has to be data, that doesn't need to do any actions on construction or destruction, that aren't saved with the data. Or will get invalid after the Program closes. The Manager works best with primitive data types, but if you follow these rules, it can do much more.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The Manager also supports a crypted mode. But this requires CrytoPP. Check <a class="el" href="group___m_a_i_n___g_r_o_u_p.html#TANC004">STORMAN_CRYPTED</a></dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If you want to dive a little deeper into the topic, especially about storing Classes that contain stored Variables, check <a class="el" href="class_storage_variable.html" title="Storage Variable class. Use it to create a reference to variables created on storage. ">StorageVariable</a> </dd></dl>

<p>Definition at line <a class="el" href="_storage_manager_8h_source.html#l00259">259</a> of file <a class="el" href="_storage_manager_8h_source.html">StorageManager.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0b3049042f6237c8f876517432b71c1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * StorageManager::allocateStorage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>varName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alloctes new storage, using the new-operator. </p>
<p>This function is the equivalent of the new-operator for the Storage. It will create a pointer with the given parameters on the Storage. Additionally, you need to name the pointer to identify it. If the allocation via new fails, or if a varibale with the name already exists, the function will fail, either throwing an exception or returning NULL.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Pointer type parameter. </td></tr>
    <tr><td class="paramname">Args</td><td>Variadic template. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">varName</td><td>Name of the variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Variable arguments as parameters give to the constructor of the object.(optional)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>Throws a normal exception, if a variable with this name already exists </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>Throws a bad_alloc, if the new-operator fails (will rethrow this exception)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL-ptr if it fails, else a T*. </dd></dl>

<p>Definition at line <a class="el" href="_storage_manager_8h_source.html#l00500">500</a> of file <a class="el" href="_storage_manager_8h_source.html">StorageManager.h</a>.</p>

</div>
</div>
<a class="anchor" id="affd4c4b9593af7b4aaa2bfc34b7aeb4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * StorageManager::allocateStorageArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>varName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alloctes new storage, using the new[]-operator. </p>
<p>This function is the equivalent of the new[]-operator for the Storage. It will create a pointer to an arry with the default constructor on the Storage. Additionally, you need to name the pointer to identify it. If the allocation via new fails, or if a varibale with the name already exists, the function will fail, either throwing an exception or returning NULL.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Pointer type parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">varName</td><td>Name of the variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size (in number of objects inside the array), that the arry should have</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>Throws a normal exception, if a variable with this name already exists </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>Throws a bad_alloc, if the new-operator fails (will rethrow this exception)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL-ptr if it fails, else a T*. </dd></dl>

<p>Definition at line <a class="el" href="_storage_manager_8h_source.html#l00540">540</a> of file <a class="el" href="_storage_manager_8h_source.html">StorageManager.h</a>.</p>

</div>
</div>
<a class="anchor" id="a882341510e70c5075558b3bef9aa21c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Completly clears the manager. </p>
<p>This function will clear the Manager. This means the current one will be discarded and a new one will be created.</p>
<dl class="section warning"><dt>Warning</dt><dd>Only call this function if neccessary, because all pointers refering to the Storage will be deleted. Pleace notice, thath if StorageManager::autoSave is set, all data will be saved before clearing. And if load was not disabled, it will instantly reload the file.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">nothrow</td><td>This function will never throw an exception </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_storage_manager_8cpp_source.html#l00655">655</a> of file <a class="el" href="_storage_manager_8cpp_source.html">StorageManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a412c525465f38801e631e45286b53071"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StorageManager::contains </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks, if a variable with this name exists on storage. </p>
<p>Scans the Storage looking for the Variable with the given name, returns true, if the Manager has a variable with this name</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The Name of the Variable tested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">nothrow</td><td>This function will never throw an exception</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the object is in the Storage, false if not. </dd></dl>

<p>Definition at line <a class="el" href="_storage_manager_8cpp_source.html#l00212">212</a> of file <a class="el" href="_storage_manager_8cpp_source.html">StorageManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8f5f5146ce3049f52cd6dd1303cec451"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StorageManager::copyPointer </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replace</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a copy of the pointers data. </p>
<p>Can be used to copy the data pointed by a pointer. It will create a new pointer with the spacer at the Storage and create a binary copy of the given pointer. Won't call any constructors or other functions on the copied object on construction, but it will call the destructor if removed</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Pointer type parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the Variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>The pointer to obtain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the pointer (in Elements). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replace</td><td>If an variable with this name already exists, set true to replace it, false to keep it. Default is true. (optional)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Will be thrown, if new fails</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the pointer was successfully copied, false if not. </dd></dl>

<p>Definition at line <a class="el" href="_storage_manager_8h_source.html#l00730">730</a> of file <a class="el" href="_storage_manager_8h_source.html">StorageManager.h</a>.</p>

</div>
</div>
<a class="anchor" id="afeef0cdabd4c32d40a9cef9d649bb0de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; void * &gt; &amp; StorageManager::CorruptedPointers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to a vector, that stores all the pointers, which were deleted on loading. </p>
<p>Will return the vector, that contains alls pointers, that have been allocetd before, but are now (because of <a class="el" href="class_storage_manager.html#ab90db630d2bc803252cf587e0c558398" title="Loads all available data from the Harddrive to the Storage. ">StorageManager::load</a>, e.g.) are invalid.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">nothrow</td><td>This function will never throw an exception</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the coruption vector. </dd></dl>

<p>Definition at line <a class="el" href="_storage_manager_8cpp_source.html#l00686">686</a> of file <a class="el" href="_storage_manager_8cpp_source.html">StorageManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="adf6f89757ecb95cc74475dfa1432458f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_storage_variable.html">StorageVariable</a>&lt; T &gt; StorageManager::createArray </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unique</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enforce</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enforce_size</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="class_storage_variable.html" title="Storage Variable class. Use it to create a reference to variables created on storage. ">StorageVariable</a> to the given Name, array version. </p>
<p>This function will create a <a class="el" href="class_storage_variable.html" title="Storage Variable class. Use it to create a reference to variables created on storage. ">StorageVariable</a> to an array. The function internally behaves like <a class="el" href="class_storage_manager.html#a477984c70411871967e3d44a92a249d8" title="Gets an arry pointer at the Storage, either an existing one or creates a new one. ...">StorageManager::getArray</a>. But after retrieving the pointer, it will create a <a class="el" href="class_storage_variable.html" title="Storage Variable class. Use it to create a reference to variables created on storage. ">StorageVariable</a> from it. If unique is set to true, a new Variable with id will be created, if not, it will share it's ID with other StorageVariables. If Unique is the to true, the Variable will be uncopyable. It's not recommended to make a <a class="el" href="class_storage_variable.html" title="Storage Variable class. Use it to create a reference to variables created on storage. ">StorageVariable</a> unique, because making it shareable this will save Memory and Storage.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td><a class="el" href="class_storage_variable.html" title="Storage Variable class. Use it to create a reference to variables created on storage. ">StorageVariable</a> type parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the Variable to refer to. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">size</td><td>The size(in elements) the array should have/has. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unique</td><td>true if the Variable should be unique. Default is false. (optional) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enforce</td><td>true to enforce the creation, if a variable with the name already exists, but is different. If true, the old one will be deleted, if false, the function fails. Default is false. (optional) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enforce_size</td><td>true to enforce the the size of the array. If the array found has a different size and this is set to true, the function will fail/recretead (depending on enfroce). Default is false. (optional)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Will be thrown, if a new-operator fails </td></tr>
    <tr><td class="paramname">std::exception</td><td>Will be thrown, if enforce is set to false, but the pointer found has a different type (or size), is not an array or there are no free indexes for a Variable left.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new <a class="el" href="class_storage_variable.html" title="Storage Variable class. Use it to create a reference to variables created on storage. ">StorageVariable</a>, refering to the pointer with the given name (Check <a class="el" href="class_storage_variable.html#a1f5dc54896f4d79ab94c4eacc6a2b9ab" title="Checks if this reference is valid. ">StorageVariable::isValid</a> to find out if this function succeeded or not). </dd></dl>

<p>Definition at line <a class="el" href="_storage_manager_8h_source.html#l01145">1145</a> of file <a class="el" href="_storage_manager_8h_source.html">StorageManager.h</a>.</p>

</div>
</div>
<a class="anchor" id="a136edf2a78edf3ef24241b02d825e234"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_storage_variable.html">StorageVariable</a>&lt; T &gt; StorageManager::createVariable </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unique</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enforce</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="class_storage_variable.html" title="Storage Variable class. Use it to create a reference to variables created on storage. ">StorageVariable</a> to the given Name. </p>
<p>This function will create a <a class="el" href="class_storage_variable.html" title="Storage Variable class. Use it to create a reference to variables created on storage. ">StorageVariable</a>. It internally behaves like <a class="el" href="class_storage_manager.html#a8189940dad5e0d901d93acdd08f4909b" title="Gets a pointer at the Storage, either an existing one or creates a new one. ">StorageManager::getVariable</a>. But after retrieving the pointer, it will create a <a class="el" href="class_storage_variable.html" title="Storage Variable class. Use it to create a reference to variables created on storage. ">StorageVariable</a> from it. If unique is set to true, a new variable with id will be created, if not, it will share it's ID with other StorageVariables. If unique is the to true, the Variable will be uncopyable. It's not recommended to make a <a class="el" href="class_storage_variable.html" title="Storage Variable class. Use it to create a reference to variables created on storage. ">StorageVariable</a> unique, because making it shareable this will save Memory and Storage.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td><a class="el" href="class_storage_variable.html" title="Storage Variable class. Use it to create a reference to variables created on storage. ">StorageVariable</a> type parameter. </td></tr>
    <tr><td class="paramname">Args</td><td>Variadic Template. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the Variable to refer to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unique</td><td>true if the Variable should be unique. Default is false. (optional) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enforce</td><td>true to enforce the creation, if a variable with the name already exists, but is different. If true, the old one will be deleted, if false, the function fails. Default is false. (optional) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Variable arguments, that will be given to the constructor, if a new construction is needed (Will be ignored, if the variable already exists). (optional)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Will be thrown, if a new-operator fails </td></tr>
    <tr><td class="paramname">std::exception</td><td>Will be thrown, if enforce is set to false, but the pointer found has a different type (or size), is an array or there are no free indexes for a Variable left.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new <a class="el" href="class_storage_variable.html" title="Storage Variable class. Use it to create a reference to variables created on storage. ">StorageVariable</a>, refering to the pointer with the given name (Check <a class="el" href="class_storage_variable.html#a1f5dc54896f4d79ab94c4eacc6a2b9ab" title="Checks if this reference is valid. ">StorageVariable::isValid</a> to find out if this function succeeded or not). </dd></dl>

<p>Definition at line <a class="el" href="_storage_manager_8h_source.html#l01069">1069</a> of file <a class="el" href="_storage_manager_8h_source.html">StorageManager.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae6750cf63f61a20cfb34d93a1444a99a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t StorageManager::derefVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_storage_variable.html">StorageVariable</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes 1 reference to the variable used by var and makes var invalid. </p>
<p>Will dereference and delete the given <a class="el" href="class_storage_variable.html" title="Storage Variable class. Use it to create a reference to variables created on storage. ">StorageVariable</a> (Without deleting the pointer it refers to). This is needed because many StorageVariables share one ID. This way dead links won't occure. This function will automatically be called in the destructor of the Variable. If the Dereference succeeds, the <a class="el" href="class_storage_variable.html" title="Storage Variable class. Use it to create a reference to variables created on storage. ">StorageVariable</a> will be made invalid. If this function is used on an invalid <a class="el" href="class_storage_variable.html" title="Storage Variable class. Use it to create a reference to variables created on storage. ">StorageVariable</a>, it won't do anything</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the <a class="el" href="class_storage_variable.html" title="Storage Variable class. Use it to create a reference to variables created on storage. ">StorageVariable</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">var</td><td>The <a class="el" href="class_storage_variable.html" title="Storage Variable class. Use it to create a reference to variables created on storage. ">StorageVariable</a>, that should be deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">nothrow</td><td>This function never throws exceptions</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of references left on the Variable the <a class="el" href="class_storage_variable.html" title="Storage Variable class. Use it to create a reference to variables created on storage. ">StorageVariable</a> was refering to. </dd></dl>

<p>Definition at line <a class="el" href="_storage_manager_8h_source.html#l01216">1216</a> of file <a class="el" href="_storage_manager_8h_source.html">StorageManager.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0ac90cb452767a5e39a3e0d820cfc53c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::freeStorage </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>storagePointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the storage pointed by storagePointer. </p>
<p>Use this function to free a pointer declared on Storage. If the pointer is in Storage, it will be deleted, if not, the function does nothing</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">storagePointer</td><td>The pointer to be freed</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">nothrow</td><td>This function will never throw an exception </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_storage_manager_8cpp_source.html#l00186">186</a> of file <a class="el" href="_storage_manager_8cpp_source.html">StorageManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a32015eaf54467ed3c5c1cb317e92335f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::generateRandom </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keylenght</em> = <code>CryptoPP::AES::DEFAULT_KEYLENGTH</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Randomly generates a key and an iv. </p>
<p>Will generate a new Key and iv, using the <a href="http://www.cryptopp.com/docs/ref/class_auto_seeded_random_pool.html">AutoSeededRandomPool</a>. Use Keylenght to determine the key's size. They can be retrieved via <a class="el" href="class_storage_manager.html#a94dd86710068d0df906c4a5b74fafd0e" title="Gets if the file should be crypted and if needed it&#39;s key. ">StorageManager::getCrypted</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keylenght</td><td>the Lenght, in Bytes, the AES-Key shoudl have</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CryptoPP::Exception</td><td>will be thrown, if an error within the key generation occures. Check <a href="http://www.cryptopp.com/docs/ref/class_exception.html">Exception</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_storage_manager_8cpp_source.html#l00891">891</a> of file <a class="el" href="_storage_manager_8cpp_source.html">StorageManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a477984c70411871967e3d44a92a249d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * StorageManager::getArray </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enforce</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enforce_size</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an arry pointer at the Storage, either an existing one or creates a new one. </p>
<p>This function is basically a combination of <a class="el" href="class_storage_manager.html#affd4c4b9593af7b4aaa2bfc34b7aeb4b" title="Alloctes new storage, using the new[]-operator. ">StorageManager::allocateStorageArray</a> and <a class="el" href="class_storage_manager.html#a9472bef7ba9a5333433a3931e8181e9e" title="Returns the pointer to the variable specified by name. ">StorageManager::getPointer</a>. On call, it will first search the Manager for a variable with the given name. If it was found, and is of the same type (and an array), it's pointer will be returned. If it was not found, or if types are different, but enforce is set to true, a new Variable with this name will be created (using the given parameters) and returned. <br />
</p><dl class="section attention"><dt>Attention</dt><dd>This function will fail/recreate, if you want to get a previously created bariable of given type and name, but it's not an array. Using the enforce_size parameter, you can specify, how the function will behave, if only the size is not the same as given</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Pointer type parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the variable. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">size</td><td>The size(in elements) the array should have/has. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enforce</td><td>true to enforce the creation, if a variable with the name already exists, but is different. If true, the old one will be deleted, if false, the function fails. Default is false. (optional) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enforce_size</td><td>true to enforce the the size of the array. If the array found has a different size and this is set to true, the function will fail/recretead (depending on enfroce). Default is false. (optional)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Will be thrown, if a new-operator fails </td></tr>
    <tr><td class="paramname">std::exception</td><td>Will be thrown, if enforce is set to false, but the pointer found has a different type (or size) or is not an array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if the Variable has a different type/size as the given one, else the pointer to the variable. </dd></dl>

<p>Definition at line <a class="el" href="_storage_manager_8h_source.html#l00956">956</a> of file <a class="el" href="_storage_manager_8h_source.html">StorageManager.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac76b83d64ca60038d49a092115e3348c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StorageManager::getAutoSave </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the AutoSave parameter. </p>
<p>Will get the autoSave parameter. If it's set to true, the Manager will automatically save the Storage on it's destruction</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">nothrow</td><td>This function will never throw an exception</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the autoSave parameter </dd></dl>

<p>Definition at line <a class="el" href="_storage_manager_8cpp_source.html#l00748">748</a> of file <a class="el" href="_storage_manager_8cpp_source.html">StorageManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a94dd86710068d0df906c4a5b74fafd0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StorageManager::getCrypted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets if the file should be crypted and if needed it's key. </p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>Overloaded function, Will return, if Crypted mode is currently active, without returning giving key and iv.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">nothrow</td><td>This function will never throw an exception</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns if currently crypted mode is activ </dd></dl>

<p>Definition at line <a class="el" href="_storage_manager_8cpp_source.html#l00955">955</a> of file <a class="el" href="_storage_manager_8cpp_source.html">StorageManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8e3d81bd37c54f4ae327529944897811"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StorageManager::getCrypted </td>
          <td>(</td>
          <td class="paramtype">CryptoPP::SecByteBlock &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CryptoPP::SecByteBlock &amp;&#160;</td>
          <td class="paramname"><em>iv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Will return, if Crypted mode is currently active, and will copy the current key and iv to key and iv. Key and iv can have valid values, even if the Manager currently does not use encryption. Key and iv are <a href="http://www.cryptopp.com/docs/ref/class_sec_block.html">SecByteBlocks</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">key</td><td>the key, used for AES-En/Decryption </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iv</td><td>the iv, used to initialize the AES-En/Decryption</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">nothrow</td><td>This function will never throw an exception</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns if currently crypted mode is active </dd></dl>

<p>Definition at line <a class="el" href="_storage_manager_8cpp_source.html#l00936">936</a> of file <a class="el" href="_storage_manager_8cpp_source.html">StorageManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a886ed1ec85ec9f2e4a9d1eb549768db3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_a_i_n___g_r_o_u_p.html#ga2b1d394c674416b3d00c8bf887e3a4f4">StorageManager::LoadPolicy</a> StorageManager::getLoadPolicy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the LoadPolicy parameter. </p>
<p>Will get the loadPolicy parameter. Depending on the load policy, the Manager will behave different on how to react to data duplicates. Check <a class="el" href="group___m_a_i_n___g_r_o_u_p.html#ga2b1d394c674416b3d00c8bf887e3a4f4" title="Possible behaviors to load the data. ">StorageManager::LoadPolicy</a> for more information</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">nothrow</td><td>This function will never throw an exception</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the loadPolicy parameter </dd></dl>

<p>Definition at line <a class="el" href="_storage_manager_8cpp_source.html#l00812">812</a> of file <a class="el" href="_storage_manager_8cpp_source.html">StorageManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a744996bc2fe9beb4e54010083b772950"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string StorageManager::getLoadProtocol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the loading-protokol. </p>
<p>Will return the Protokol, created by the <a class="el" href="class_storage_manager.html#ab90db630d2bc803252cf587e0c558398" title="Loads all available data from the Harddrive to the Storage. ">StorageManager::load</a> function</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">nothrow</td><td>This function will never throw an exception</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The load protocol. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="_storage_variable_example_8cpp-example.html#a2">StorageVariableExample.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_storage_manager_8cpp_source.html#l00670">670</a> of file <a class="el" href="_storage_manager_8cpp_source.html">StorageManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab2d626d5a89e26d0b274720df2c5791d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string StorageManager::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the Name parameter. </p>
<p>Will get the name of the Programs Data as a group. This is the name, the data will be saved under, if you call <a class="el" href="class_storage_manager.html#a5c6027ebf6fac01093a9624e6c846c85" title="Saves all the Storage data to the Harddrive. ">StorageManager::save</a>. The StorageManager::verifyName parameter will specify, how the name affects loading</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">nothrow</td><td>This function will never throw an exception</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the current name </dd></dl>

<p>Definition at line <a class="el" href="_storage_manager_8cpp_source.html#l00844">844</a> of file <a class="el" href="_storage_manager_8cpp_source.html">StorageManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0b37bf042283a20138fa084703336f33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StorageManager::getNothrow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the nothrow parameter. </p>
<p>Will get the nothrow parameter. If it's set to true, the Manager won't throw any exceptions. This means all exceptions will be caught by the functions themselfes and their return value will indicate that something went wrong</p>
<dl class="section return"><dt>Returns</dt><dd>returns the nothrow parameter </dd></dl>

<p>Definition at line <a class="el" href="_storage_manager_8cpp_source.html#l00718">718</a> of file <a class="el" href="_storage_manager_8cpp_source.html">StorageManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4fd81fd234ba5547e0a85be4b2275c3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string StorageManager::getPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the Path parameter. </p>
<p>Will get the filepath that will be used to save the data, so basically the file to store the data</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">nothrow</td><td>This function will never throw an exception</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the current path </dd></dl>

<p>Definition at line <a class="el" href="_storage_manager_8cpp_source.html#l00874">874</a> of file <a class="el" href="_storage_manager_8cpp_source.html">StorageManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9472bef7ba9a5333433a3931e8181e9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * StorageManager::getPointer </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the pointer to the variable specified by name. </p>
<p>Scans the Storage for a Variable with the given Name, and if it exists, returns the pointer to it. Otherwise retuens the NULL-pointer. If the Variable was only loaded, not used yet, this function will call StorageManager::revivePointer, to move the Variable from load Space to active Space. This can slow down the process a little bit, and if an internal error occures, throw exceptions</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Pointer type parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>Indicates, that an internal copy-action failed or the types are different </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>Throws a bad_alloc, if the new-operator fails (will rethrow this exception)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if it fails, else the pointer. </dd></dl>

<p>Definition at line <a class="el" href="_storage_manager_8h_source.html#l00579">579</a> of file <a class="el" href="_storage_manager_8h_source.html">StorageManager.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8189940dad5e0d901d93acdd08f4909b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * StorageManager::getVariable </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enforce</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a pointer at the Storage, either an existing one or creates a new one. </p>
<p>This function is basically a combination of <a class="el" href="class_storage_manager.html#a0b3049042f6237c8f876517432b71c1d" title="Alloctes new storage, using the new-operator. ">StorageManager::allocateStorage</a> and <a class="el" href="class_storage_manager.html#a9472bef7ba9a5333433a3931e8181e9e" title="Returns the pointer to the variable specified by name. ">StorageManager::getPointer</a>. On call, it will first search the Manager for a variable with the given name. If it was found, and is of the same type, it's pointer will be returned. If it was not found, or if types are different, but enforece is set to true, a new variable with this name will be created (using the given parameters) and returned. <br />
</p><dl class="section attention"><dt>Attention</dt><dd>This function will fail/recreate, if you want to get a previously created variable of given type and name, but an array</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Pointer type parameter. </td></tr>
    <tr><td class="paramname">Args</td><td>Variadic template. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enforce</td><td>true to enforce the creation, if a variable with the name already exists, but is different. If true, the old one will be deleted, if false, the function fails. Default is false. (optional) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Variable arguments, that will be given to the constructor, if a new construction is needed (Will be ignored, if the variable already exists). (optional)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Will be thrown, if a new-operator fails </td></tr>
    <tr><td class="paramname">std::exception</td><td>Will be thrown, if enforce is set to false, but the pointer found has a different type or is an array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if the Variable has a different type/size as the given one, else the pointer to the variable. </dd></dl>

<p>Definition at line <a class="el" href="_storage_manager_8h_source.html#l00884">884</a> of file <a class="el" href="_storage_manager_8h_source.html">StorageManager.h</a>.</p>

</div>
</div>
<a class="anchor" id="a457c9ffcd7714f10cefc8c6cbe615a02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StorageManager::getVerifyName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the VerifyName parameter. </p>
<p>Will get the verifyName parameter. If it's set to true, the Manager will compare the name stated in the file loaded with the setted name. If they are different, the operation will fail. If set to false, it will obtain the name</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">nothrow</td><td>This function will never throw an exception</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the verifyName parameter </dd></dl>

<p>Definition at line <a class="el" href="_storage_manager_8cpp_source.html#l00780">780</a> of file <a class="el" href="_storage_manager_8cpp_source.html">StorageManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab90db630d2bc803252cf587e0c558398"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StorageManager::load </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads all available data from the Harddrive to the Storage. </p>
<p>Used to load Data from the Harddisk into the <a class="el" href="class_storage_manager.html" title="A Static class, that simulates a fourth area to declare Variables, which is the Harddrive to keep the...">StorageManager</a>. If the file is a valid StorageManager-xml-file, nothing should go wrong, but because loading is always harder then saving, this function will write a protokol about what it loaded and when and where errors occured. Because of that it won't throw exceptions. If an error is dectected, it will write it to the Protokol and return false. If everything works without problems, it will return true. But every kind of data read in will be added to the protokol. Call <a class="el" href="class_storage_manager.html#a744996bc2fe9beb4e54010083b772950" title="Returns the loading-protokol. ">StorageManager::getLoadProtocol</a> to get the protocol</p>
<dl class="section remark"><dt>Remarks</dt><dd>If <a class="el" href="group___m_a_i_n___g_r_o_u_p.html#TANC004">STORMAN_CRYPTED</a> is defined, this function will automatically decrypt the file before reading it.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The Manager will automatically call this function on it's construction. To prevent this, or to modify the way this will be done, check the following constants: <br />
 <a class="el" href="group___m_a_i_n___g_r_o_u_p.html#TANC001">STORMAN_NOLOAD</a> <br />
 <a class="el" href="group___m_a_i_n___g_r_o_u_p.html#TANC002">STORMAN_PERSONAL_NAME</a> <br />
 <a class="el" href="group___m_a_i_n___g_r_o_u_p.html#TANC003">STORMAN_PERSONAL_PATH</a> <br />
 <a class="el" href="group___m_a_i_n___g_r_o_u_p.html#TANC004">STORMAN_CRYPTED</a></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">nothrow</td><td>This function will never throw an exception</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it succeeds, false if it fails. </dd></dl>

<p>Definition at line <a class="el" href="_storage_manager_8cpp_source.html#l00372">372</a> of file <a class="el" href="_storage_manager_8cpp_source.html">StorageManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac884d39bef24dfdefbe4afbe1999d89d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StorageManager::observePointer </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replace</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Observes a pointer. </p>
<p>Can be used to obsever the given pointer. Observation in this case means, that the pointer will be added to the <a class="el" href="class_storage_manager.html" title="A Static class, that simulates a fourth area to declare Variables, which is the Harddrive to keep the...">StorageManager</a>, but the manager won't take ownership of the pointer, which means it won't delete it, even if you call <a class="el" href="class_storage_manager.html#a257d70bad26e2b6e3ab1241f3725830e" title="Permanently deletes the variable name from the storage. ">StorageManager::removeVariable</a> or <a class="el" href="class_storage_manager.html#a0ac90cb452767a5e39a3e0d820cfc53c" title="Frees the storage pointed by storagePointer. ">StorageManager::freeStorage</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Be careful with this function. The Manager won't notice, if the pointer gets invalid. So if you use auto-save, make shure the given pointer won't be deleted before the Manager. (Manager is located in DataSegment). </dd>
<dd>
NEVER use this function on pointers returned by functions like std::vector::data or std::string::data, because these pointers ar not consistent. As soon as you change the content of e.g. a string, it will delete the old pointer and create a new one - which will cause the Manager to crush. If you want to store the data such a pointer referes to, use <a class="el" href="class_storage_manager.html#a8f5f5146ce3049f52cd6dd1303cec451" title="Creates a copy of the pointers data. ">StorageManager::copyPointer</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Pointer type parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the Variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>The pointer to obtain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the pointer (in Elements). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replace</td><td>If an variable with this name already exists, set true to replace it, false to keep it. Default is true. (optional)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">nothrow</td><td>Never throws an exception</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the pointer was successfully copied, false if not. </dd></dl>

<p>Definition at line <a class="el" href="_storage_manager_8h_source.html#l00787">787</a> of file <a class="el" href="_storage_manager_8h_source.html">StorageManager.h</a>.</p>

</div>
</div>
<a class="anchor" id="afa3e8aee088d707318e9801e4d0e611b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StorageManager::obtainPointer </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replace</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves a pointer from heap to storage. </p>
<p>This function will move pointer from the heap to the Storage. Internally, it will take ownership of the given pointer, from now on beeing responsible for the pointer. Can be used to transfer pointers to the Storage.</p>
<dl class="section warning"><dt>Warning</dt><dd>Be careful with this function, because once the Storage obtained the pointer, it later will delete it. So don't pass pointer returned by functions or from variables, that are not located at the Heap. Only use, if you should later delete the pointer - and if you move the pointer, don't delete it yourself. <br />
 Another important thing to take care of: Do never obtain pointers, like the std::vector::data function will return you, because the vector won't give you the ownership, it will keep it. Use <a class="el" href="class_storage_manager.html#a8f5f5146ce3049f52cd6dd1303cec451" title="Creates a copy of the pointers data. ">StorageManager::copyPointer</a> to save such data.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Pointer type parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the Variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>The pointer to obtain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the pointer (in Elements). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replace</td><td>If an variable with this name already exists, set true to replace it, false to keep it. Default is true. (optional)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">nothrow</td><td>This function never throws exceptions</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the pointer was successfully obtained, false if not. </dd></dl>

<p>Definition at line <a class="el" href="_storage_manager_8h_source.html#l00694">694</a> of file <a class="el" href="_storage_manager_8h_source.html">StorageManager.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac2d760901a3b7b5cd9e830f7992d8504"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * StorageManager::releasePointer </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>isArray</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes the pointer from Storage and moves it to the heap. </p>
<p>Will detach the given variable frome the Storage, meaning it will completly be removed from the Storage and moved to the heap. For the Manager it does the same as <a class="el" href="class_storage_manager.html#a257d70bad26e2b6e3ab1241f3725830e" title="Permanently deletes the variable name from the storage. ">StorageManager::removeVariable</a>, but without deleting it from the Heap</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Generic type parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the Variable. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>If non-NULL, the size of the released pointer will be written to size. (optional) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">isArray</td><td>If non-NULL, will be set to true if the pointer was created by new[], else is set to false (Use to finde out if delete or delete[] should be used). (optional)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>Indicates, that the types are different</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if there is no pointer with this name or the type is not the same, else the pointer. </dd></dl>

<p>Definition at line <a class="el" href="_storage_manager_8h_source.html#l00822">822</a> of file <a class="el" href="_storage_manager_8h_source.html">StorageManager.h</a>.</p>

</div>
</div>
<a class="anchor" id="a257d70bad26e2b6e3ab1241f3725830e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StorageManager::removeVariable </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permanently deletes the variable name from the storage. </p>
<p>Scans the Storage looking for the variable with the given name. If one was found, it will be deleted and the pointer it that it was will be added to the Corruption list. It will only add the pointer, if it was in use. Data loaded via <a class="el" href="class_storage_manager.html#ab90db630d2bc803252cf587e0c558398" title="Loads all available data from the Harddrive to the Storage. ">StorageManager::load</a>, that was not used won't be added to the list. Returns true, if a variable with this name was removed. Call <a class="el" href="class_storage_manager.html#afeef0cdabd4c32d40a9cef9d649bb0de" title="Returns a reference to a vector, that stores all the pointers, which were deleted on loading...">StorageManager::CorruptedPointers</a> to get a reference to the corrupted pointer list. The newst one will always be pushed back to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the variable to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">nothrow</td><td>This function will never throw an exception</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it succeeds, false if it fails. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="_storage_variable_example_8cpp-example.html#a1">StorageVariableExample.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_storage_manager_8cpp_source.html#l00240">240</a> of file <a class="el" href="_storage_manager_8cpp_source.html">StorageManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5c6027ebf6fac01093a9624e6c846c85"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StorageManager::save </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saves all the Storage data to the Harddrive. </p>
<p>Explicitly stores the data in the Storage in the specified file, using a special XML-Format. All Data, that is allocated in the Storage at the time this function is called will be stored in binary form on your Harddrive, wrapped in XML. <br />
 If you want to change the path or name use the give functions</p>
<dl class="section remark"><dt>Remarks</dt><dd>If <a class="el" href="group___m_a_i_n___g_r_o_u_p.html#TANC004">STORMAN_CRYPTED</a> is defined, this function will automatically encrypt the data, before saving it</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Because of how the Manager works, in some places symbols will be replaced by others (Only within attributes or texts). It will use the normal XML-escape-sequences, The file itself will be written in ASCII, which may be problematic if open by other programs.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">nothrow</td><td>This function will never throw an exception</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it succeeds, false if it fails. </dd></dl>

<p>Definition at line <a class="el" href="_storage_manager_8cpp_source.html#l00279">279</a> of file <a class="el" href="_storage_manager_8cpp_source.html">StorageManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a35fe2b8483b8a93e14faee59d8f71d55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::setAutoSave </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the AutoSave parameter. </p>
<p>Will set the autoSave parameter. If it's set to true, the Manager will automatically save the Storage on it's destruction</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the autosave-value</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">nothrow</td><td>This function will never throw an exception </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_storage_manager_8cpp_source.html#l00733">733</a> of file <a class="el" href="_storage_manager_8cpp_source.html">StorageManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a91892b0d109b21e13ff54e8fa32be55f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::setCrypted </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CryptoPP::SecByteBlock &amp;&#160;</td>
          <td class="paramname"><em>key</em> = <code>CryptoPP::SecByteBlock()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CryptoPP::SecByteBlock &amp;&#160;</td>
          <td class="paramname"><em>iv</em> = <code>CryptoPP::SecByteBlock()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets if the file should be crypted with a key. </p>
<p>Will set the data related to encryption, including key and iv, using the <a href="http://www.cryptopp.com/docs/ref/class_sec_block.html">SecByteBlock</a></p>
<dl class="section attention"><dt>Attention</dt><dd>If key or iv are empty, the will be resetted. If you set value true, always set key and iv valid, too</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the crypted-value, true if Crypted mode should be used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>the key, used for AES-En/Decryption </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iv</td><td>the iv, used to initialize the AES-En/Decryption</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">nothrow</td><td>This function will never throw an exception </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_storage_manager_8cpp_source.html#l00914">914</a> of file <a class="el" href="_storage_manager_8cpp_source.html">StorageManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5145182a002c2b1d26c2bd1ee7bce9ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::setLoadPolicy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_a_i_n___g_r_o_u_p.html#ga2b1d394c674416b3d00c8bf887e3a4f4">StorageManager::LoadPolicy</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the LoadPolicy parameter. </p>
<p>Will set the loadPolicy parameter. Depending on the load policy, the Manager will behave different on how to react to data duplicates. Check <a class="el" href="group___m_a_i_n___g_r_o_u_p.html#ga2b1d394c674416b3d00c8bf887e3a4f4" title="Possible behaviors to load the data. ">StorageManager::LoadPolicy</a> for more information</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the LoadPolicy</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">nothrow</td><td>This function will never throw an exception </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_storage_manager_8cpp_source.html#l00796">796</a> of file <a class="el" href="_storage_manager_8cpp_source.html">StorageManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab40c05ee1f87944e2b12c78a1650a36f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::setName </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the Name parameter. </p>
<p>Will set the name of the Programs Data as a group. This is the name, the data will be saved under, if you call <a class="el" href="class_storage_manager.html#a5c6027ebf6fac01093a9624e6c846c85" title="Saves all the Storage data to the Harddrive. ">StorageManager::save</a>. The StorageManager::verifyName parameter will specify, how the name affects loading</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the Program's name</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">nothrow</td><td>This function will never throw an exception </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_storage_manager_8cpp_source.html#l00828">828</a> of file <a class="el" href="_storage_manager_8cpp_source.html">StorageManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a802b1e7c12fb17783fac32c075fc792d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::setNothrow </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the nothrow parameter. </p>
<p>Will set the nothrow parameter. If it's set to true, the Manager won't throw any exceptions. This means all exceptions will be caught by the functions themselfes and their return value will indicate that something went wrong</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the throw-value, false if exceptions should be thrown</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">nothrow</td><td>This function will never throw an exception </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_storage_manager_8cpp_source.html#l00703">703</a> of file <a class="el" href="_storage_manager_8cpp_source.html">StorageManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeca281716c780a4cf2ca6ee1fba96fc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::setPath </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the Path parameter. </p>
<p>Will set the filepath that will be used to save the data, so basically the file to store the data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the file to the Manager</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">nothrow</td><td>This function will never throw an exception </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_storage_manager_8cpp_source.html#l00859">859</a> of file <a class="el" href="_storage_manager_8cpp_source.html">StorageManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab3011c9d7bef056ec6f10d009ad14172"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::setVerifyName </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the VerifyName parameter. </p>
<p>Will set the verifyName parameter. If it's set to true, the Manager will compare the name stated in the file loaded with the setted name. If they are different, the operation will fail. If set to false, it will obtain the name</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the setVerify-value, true if the Manager will try to verify</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">nothrow</td><td>This function will never throw an exception </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_storage_manager_8cpp_source.html#l00764">764</a> of file <a class="el" href="_storage_manager_8cpp_source.html">StorageManager.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a8359a9e15d03cc2504a11a8a22a1d57c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_storage_variable.html">StorageVariable</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_storage_manager_8h_source.html#l00261">261</a> of file <a class="el" href="_storage_manager_8h_source.html">StorageManager.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>StorageManager/<a class="el" href="_storage_manager_8h_source.html">StorageManager.h</a></li>
<li>StorageManager/<a class="el" href="_storage_manager_8cpp_source.html">StorageManager.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Oct 25 2014 14:48:52 for StorageManager by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
